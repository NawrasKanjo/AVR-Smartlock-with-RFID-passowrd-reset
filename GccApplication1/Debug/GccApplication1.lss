
GccApplication1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  0000054c  000005e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000054c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000020  00800116  00800116  000005f6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000005f6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000628  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000050  00000000  00000000  00000668  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000bd0  00000000  00000000  000006b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000094a  00000000  00000000  00001288  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000005d0  00000000  00000000  00001bd2  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000000c0  00000000  00000000  000021a4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004df  00000000  00000000  00002264  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000040e  00000000  00000000  00002743  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000058  00000000  00000000  00002b51  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	bc c0       	rjmp	.+376    	; 0x17a <__ctors_end>
   2:	00 00       	nop
   4:	d7 c0       	rjmp	.+430    	; 0x1b4 <__bad_interrupt>
   6:	00 00       	nop
   8:	d5 c0       	rjmp	.+426    	; 0x1b4 <__bad_interrupt>
   a:	00 00       	nop
   c:	d3 c0       	rjmp	.+422    	; 0x1b4 <__bad_interrupt>
   e:	00 00       	nop
  10:	d1 c0       	rjmp	.+418    	; 0x1b4 <__bad_interrupt>
  12:	00 00       	nop
  14:	cf c0       	rjmp	.+414    	; 0x1b4 <__bad_interrupt>
  16:	00 00       	nop
  18:	cd c0       	rjmp	.+410    	; 0x1b4 <__bad_interrupt>
  1a:	00 00       	nop
  1c:	cb c0       	rjmp	.+406    	; 0x1b4 <__bad_interrupt>
  1e:	00 00       	nop
  20:	c9 c0       	rjmp	.+402    	; 0x1b4 <__bad_interrupt>
  22:	00 00       	nop
  24:	c7 c0       	rjmp	.+398    	; 0x1b4 <__bad_interrupt>
  26:	00 00       	nop
  28:	c5 c0       	rjmp	.+394    	; 0x1b4 <__bad_interrupt>
  2a:	00 00       	nop
  2c:	c3 c0       	rjmp	.+390    	; 0x1b4 <__bad_interrupt>
  2e:	00 00       	nop
  30:	c1 c0       	rjmp	.+386    	; 0x1b4 <__bad_interrupt>
  32:	00 00       	nop
  34:	bf c0       	rjmp	.+382    	; 0x1b4 <__bad_interrupt>
  36:	00 00       	nop
  38:	bd c0       	rjmp	.+378    	; 0x1b4 <__bad_interrupt>
  3a:	00 00       	nop
  3c:	bb c0       	rjmp	.+374    	; 0x1b4 <__bad_interrupt>
  3e:	00 00       	nop
  40:	b9 c0       	rjmp	.+370    	; 0x1b4 <__bad_interrupt>
  42:	00 00       	nop
  44:	b7 c0       	rjmp	.+366    	; 0x1b4 <__bad_interrupt>
  46:	00 00       	nop
  48:	b5 c0       	rjmp	.+362    	; 0x1b4 <__bad_interrupt>
  4a:	00 00       	nop
  4c:	b3 c0       	rjmp	.+358    	; 0x1b4 <__bad_interrupt>
  4e:	00 00       	nop
  50:	b1 c0       	rjmp	.+354    	; 0x1b4 <__bad_interrupt>
  52:	00 00       	nop
  54:	af c0       	rjmp	.+350    	; 0x1b4 <__bad_interrupt>
  56:	00 00       	nop
  58:	ad c0       	rjmp	.+346    	; 0x1b4 <__bad_interrupt>
  5a:	00 00       	nop
  5c:	ab c0       	rjmp	.+342    	; 0x1b4 <__bad_interrupt>
  5e:	00 00       	nop
  60:	a9 c0       	rjmp	.+338    	; 0x1b4 <__bad_interrupt>
  62:	00 00       	nop
  64:	a7 c0       	rjmp	.+334    	; 0x1b4 <__bad_interrupt>
  66:	00 00       	nop
  68:	a5 c0       	rjmp	.+330    	; 0x1b4 <__bad_interrupt>
  6a:	00 00       	nop
  6c:	a3 c0       	rjmp	.+326    	; 0x1b4 <__bad_interrupt>
  6e:	00 00       	nop
  70:	a1 c0       	rjmp	.+322    	; 0x1b4 <__bad_interrupt>
  72:	00 00       	nop
  74:	9f c0       	rjmp	.+318    	; 0x1b4 <__bad_interrupt>
  76:	00 00       	nop
  78:	9d c0       	rjmp	.+314    	; 0x1b4 <__bad_interrupt>
  7a:	00 00       	nop
  7c:	9b c0       	rjmp	.+310    	; 0x1b4 <__bad_interrupt>
  7e:	00 00       	nop
  80:	99 c0       	rjmp	.+306    	; 0x1b4 <__bad_interrupt>
  82:	00 00       	nop
  84:	97 c0       	rjmp	.+302    	; 0x1b4 <__bad_interrupt>
  86:	00 00       	nop
  88:	95 c0       	rjmp	.+298    	; 0x1b4 <__bad_interrupt>
  8a:	00 00       	nop
  8c:	03 01       	movw	r0, r6
  8e:	33 01       	movw	r6, r6
  90:	33 01       	movw	r6, r6
  92:	33 01       	movw	r6, r6
  94:	06 01       	movw	r0, r12
  96:	33 01       	movw	r6, r6
  98:	09 01       	movw	r0, r18
  9a:	33 01       	movw	r6, r6
  9c:	33 01       	movw	r6, r6
  9e:	33 01       	movw	r6, r6
  a0:	33 01       	movw	r6, r6
  a2:	33 01       	movw	r6, r6
  a4:	33 01       	movw	r6, r6
  a6:	33 01       	movw	r6, r6
  a8:	33 01       	movw	r6, r6
  aa:	33 01       	movw	r6, r6
  ac:	33 01       	movw	r6, r6
  ae:	33 01       	movw	r6, r6
  b0:	33 01       	movw	r6, r6
  b2:	33 01       	movw	r6, r6
  b4:	33 01       	movw	r6, r6
  b6:	33 01       	movw	r6, r6
  b8:	33 01       	movw	r6, r6
  ba:	33 01       	movw	r6, r6
  bc:	33 01       	movw	r6, r6
  be:	33 01       	movw	r6, r6
  c0:	33 01       	movw	r6, r6
  c2:	33 01       	movw	r6, r6
  c4:	33 01       	movw	r6, r6
  c6:	33 01       	movw	r6, r6
  c8:	33 01       	movw	r6, r6
  ca:	33 01       	movw	r6, r6
  cc:	33 01       	movw	r6, r6
  ce:	33 01       	movw	r6, r6
  d0:	33 01       	movw	r6, r6
  d2:	33 01       	movw	r6, r6
  d4:	33 01       	movw	r6, r6
  d6:	33 01       	movw	r6, r6
  d8:	33 01       	movw	r6, r6
  da:	33 01       	movw	r6, r6
  dc:	33 01       	movw	r6, r6
  de:	33 01       	movw	r6, r6
  e0:	33 01       	movw	r6, r6
  e2:	33 01       	movw	r6, r6
  e4:	33 01       	movw	r6, r6
  e6:	33 01       	movw	r6, r6
  e8:	33 01       	movw	r6, r6
  ea:	33 01       	movw	r6, r6
  ec:	33 01       	movw	r6, r6
  ee:	33 01       	movw	r6, r6
  f0:	33 01       	movw	r6, r6
  f2:	33 01       	movw	r6, r6
  f4:	33 01       	movw	r6, r6
  f6:	33 01       	movw	r6, r6
  f8:	33 01       	movw	r6, r6
  fa:	33 01       	movw	r6, r6
  fc:	33 01       	movw	r6, r6
  fe:	33 01       	movw	r6, r6
 100:	33 01       	movw	r6, r6
 102:	33 01       	movw	r6, r6
 104:	33 01       	movw	r6, r6
 106:	33 01       	movw	r6, r6
 108:	33 01       	movw	r6, r6
 10a:	33 01       	movw	r6, r6
 10c:	0c 01       	movw	r0, r24
 10e:	33 01       	movw	r6, r6
 110:	33 01       	movw	r6, r6
 112:	33 01       	movw	r6, r6
 114:	0f 01       	movw	r0, r30
 116:	33 01       	movw	r6, r6
 118:	12 01       	movw	r2, r4
 11a:	33 01       	movw	r6, r6
 11c:	33 01       	movw	r6, r6
 11e:	33 01       	movw	r6, r6
 120:	33 01       	movw	r6, r6
 122:	33 01       	movw	r6, r6
 124:	33 01       	movw	r6, r6
 126:	33 01       	movw	r6, r6
 128:	33 01       	movw	r6, r6
 12a:	33 01       	movw	r6, r6
 12c:	33 01       	movw	r6, r6
 12e:	33 01       	movw	r6, r6
 130:	33 01       	movw	r6, r6
 132:	33 01       	movw	r6, r6
 134:	33 01       	movw	r6, r6
 136:	33 01       	movw	r6, r6
 138:	33 01       	movw	r6, r6
 13a:	33 01       	movw	r6, r6
 13c:	33 01       	movw	r6, r6
 13e:	33 01       	movw	r6, r6
 140:	33 01       	movw	r6, r6
 142:	33 01       	movw	r6, r6
 144:	33 01       	movw	r6, r6
 146:	33 01       	movw	r6, r6
 148:	33 01       	movw	r6, r6
 14a:	33 01       	movw	r6, r6
 14c:	15 01       	movw	r2, r10
 14e:	33 01       	movw	r6, r6
 150:	33 01       	movw	r6, r6
 152:	33 01       	movw	r6, r6
 154:	18 01       	movw	r2, r16
 156:	33 01       	movw	r6, r6
 158:	1b 01       	movw	r2, r22
 15a:	33 01       	movw	r6, r6
 15c:	33 01       	movw	r6, r6
 15e:	33 01       	movw	r6, r6
 160:	33 01       	movw	r6, r6
 162:	33 01       	movw	r6, r6
 164:	33 01       	movw	r6, r6
 166:	33 01       	movw	r6, r6
 168:	33 01       	movw	r6, r6
 16a:	33 01       	movw	r6, r6
 16c:	21 01       	movw	r4, r2
 16e:	33 01       	movw	r6, r6
 170:	33 01       	movw	r6, r6
 172:	33 01       	movw	r6, r6
 174:	1e 01       	movw	r2, r28
 176:	33 01       	movw	r6, r6
 178:	2a 01       	movw	r4, r20

0000017a <__ctors_end>:
 17a:	11 24       	eor	r1, r1
 17c:	1f be       	out	0x3f, r1	; 63
 17e:	cf ef       	ldi	r28, 0xFF	; 255
 180:	d0 e4       	ldi	r29, 0x40	; 64
 182:	de bf       	out	0x3e, r29	; 62
 184:	cd bf       	out	0x3d, r28	; 61

00000186 <__do_copy_data>:
 186:	11 e0       	ldi	r17, 0x01	; 1
 188:	a0 e0       	ldi	r26, 0x00	; 0
 18a:	b1 e0       	ldi	r27, 0x01	; 1
 18c:	ec e4       	ldi	r30, 0x4C	; 76
 18e:	f5 e0       	ldi	r31, 0x05	; 5
 190:	00 e0       	ldi	r16, 0x00	; 0
 192:	0b bf       	out	0x3b, r16	; 59
 194:	02 c0       	rjmp	.+4      	; 0x19a <__do_copy_data+0x14>
 196:	07 90       	elpm	r0, Z+
 198:	0d 92       	st	X+, r0
 19a:	a6 31       	cpi	r26, 0x16	; 22
 19c:	b1 07       	cpc	r27, r17
 19e:	d9 f7       	brne	.-10     	; 0x196 <__do_copy_data+0x10>

000001a0 <__do_clear_bss>:
 1a0:	21 e0       	ldi	r18, 0x01	; 1
 1a2:	a6 e1       	ldi	r26, 0x16	; 22
 1a4:	b1 e0       	ldi	r27, 0x01	; 1
 1a6:	01 c0       	rjmp	.+2      	; 0x1aa <.do_clear_bss_start>

000001a8 <.do_clear_bss_loop>:
 1a8:	1d 92       	st	X+, r1

000001aa <.do_clear_bss_start>:
 1aa:	a6 33       	cpi	r26, 0x36	; 54
 1ac:	b2 07       	cpc	r27, r18
 1ae:	e1 f7       	brne	.-8      	; 0x1a8 <.do_clear_bss_loop>
 1b0:	36 d1       	rcall	.+620    	; 0x41e <main>
 1b2:	ca c1       	rjmp	.+916    	; 0x548 <_exit>

000001b4 <__bad_interrupt>:
 1b4:	25 cf       	rjmp	.-438    	; 0x0 <__vectors>

000001b6 <FindKey>:


//figure out witch key is pressed
int FindKey (){
	//if nothing is pressed
    if (KeypadValue==0b11110000 || KeypadValue==0b00001111)
 1b6:	86 b1       	in	r24, 0x06	; 6
 1b8:	80 3f       	cpi	r24, 0xF0	; 240
 1ba:	09 f4       	brne	.+2      	; 0x1be <FindKey+0x8>
 1bc:	4e c0       	rjmp	.+156    	; 0x25a <FindKey+0xa4>
 1be:	86 b1       	in	r24, 0x06	; 6
 1c0:	8f 30       	cpi	r24, 0x0F	; 15
 1c2:	09 f4       	brne	.+2      	; 0x1c6 <FindKey+0x10>
 1c4:	4d c0       	rjmp	.+154    	; 0x260 <FindKey+0xaa>
    {
        return -1;
    }
    int pressedPattern= KeypadValue;
 1c6:	e6 b1       	in	r30, 0x06	; 6
    KeypadDir ^= 0b11111111;
 1c8:	97 b1       	in	r25, 0x07	; 7
 1ca:	90 95       	com	r25
 1cc:	97 b9       	out	0x07, r25	; 7
    KeypadCon ^= 0b11111111;
 1ce:	98 b1       	in	r25, 0x08	; 8
 1d0:	90 95       	com	r25
 1d2:	98 b9       	out	0x08, r25	; 8
    asm volatile ("nop"); //Puts delay
 1d4:	00 00       	nop
    asm volatile ("nop"); //Puts delay
 1d6:	00 00       	nop
    pressedPattern |= KeypadValue; //*********
 1d8:	86 b1       	in	r24, 0x06	; 6
    pressedPattern &= 0b11111110; // all rows and cols except one (4x3 keypad)

	// turn green light as indicator
	ledCompoControll |= 0b00000010; // turn on green
 1da:	29 9a       	sbi	0x05, 1	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 1dc:	a7 ea       	ldi	r26, 0xA7	; 167
 1de:	b1 e6       	ldi	r27, 0x61	; 97
 1e0:	11 97       	sbiw	r26, 0x01	; 1
 1e2:	f1 f7       	brne	.-4      	; 0x1e0 <FindKey+0x2a>
 1e4:	00 c0       	rjmp	.+0      	; 0x1e6 <FindKey+0x30>
 1e6:	00 00       	nop
	_delay_ms(100);
	ledCompoControll &= 0b11111101; // turn off green
 1e8:	29 98       	cbi	0x05, 1	; 5

   
   //assign value to every key
    int key; 
	switch (pressedPattern){
 1ea:	8e 2b       	or	r24, r30
 1ec:	e8 2f       	mov	r30, r24
 1ee:	ee 7f       	andi	r30, 0xFE	; 254
 1f0:	8e 2f       	mov	r24, r30
 1f2:	90 e0       	ldi	r25, 0x00	; 0
 1f4:	fc 01       	movw	r30, r24
 1f6:	e6 57       	subi	r30, 0x76	; 118
 1f8:	f1 09       	sbc	r31, r1
 1fa:	e7 37       	cpi	r30, 0x77	; 119
 1fc:	f1 05       	cpc	r31, r1
 1fe:	98 f5       	brcc	.+102    	; 0x266 <FindKey+0xb0>
 200:	ea 5b       	subi	r30, 0xBA	; 186
 202:	ff 4f       	sbci	r31, 0xFF	; 255
 204:	98 c1       	rjmp	.+816    	; 0x536 <__tablejump2__>
        case 0b01110110:
        key = 1;
 206:	81 e0       	ldi	r24, 0x01	; 1
 208:	90 e0       	ldi	r25, 0x00	; 0
 20a:	08 95       	ret

        break;

        case 0b01111010:
        key = 2;
 20c:	82 e0       	ldi	r24, 0x02	; 2
 20e:	90 e0       	ldi	r25, 0x00	; 0
        break;
 210:	08 95       	ret

        case 0b01111100:
        key = 3;
 212:	83 e0       	ldi	r24, 0x03	; 3
 214:	90 e0       	ldi	r25, 0x00	; 0
        break;
 216:	08 95       	ret

        case 0b10110110:
        key = 4;
 218:	84 e0       	ldi	r24, 0x04	; 4
 21a:	90 e0       	ldi	r25, 0x00	; 0
        break;
 21c:	08 95       	ret

        case 0b10111010:
        key = 5;
 21e:	85 e0       	ldi	r24, 0x05	; 5
 220:	90 e0       	ldi	r25, 0x00	; 0
        break;
 222:	08 95       	ret

        case 0b10111100:
        key = 6;
 224:	86 e0       	ldi	r24, 0x06	; 6
 226:	90 e0       	ldi	r25, 0x00	; 0
        break;
 228:	08 95       	ret

        case 0b11010110:
        key = 7;
 22a:	87 e0       	ldi	r24, 0x07	; 7
 22c:	90 e0       	ldi	r25, 0x00	; 0
        break;
 22e:	08 95       	ret

        case 0b11011010:
        key = 8;
 230:	88 e0       	ldi	r24, 0x08	; 8
 232:	90 e0       	ldi	r25, 0x00	; 0
        break;
 234:	08 95       	ret

        case 0b11011100:
        key = 9;
 236:	89 e0       	ldi	r24, 0x09	; 9
 238:	90 e0       	ldi	r25, 0x00	; 0
        break;
 23a:	08 95       	ret

        case 0b11101010:
        key = 0;
 23c:	80 e0       	ldi	r24, 0x00	; 0
 23e:	90 e0       	ldi	r25, 0x00	; 0
        break;
 240:	08 95       	ret

		// this key reset the input, so you can try the code again
        case 0b11100110:
        key = 10;
		res = 1;
 242:	81 e0       	ldi	r24, 0x01	; 1
 244:	90 e0       	ldi	r25, 0x00	; 0
 246:	90 93 19 01 	sts	0x0119, r25	; 0x800119 <res+0x1>
 24a:	80 93 18 01 	sts	0x0118, r24	; 0x800118 <res>
        key = 0;
        break;

		// this key reset the input, so you can try the code again
        case 0b11100110:
        key = 10;
 24e:	8a e0       	ldi	r24, 0x0A	; 10
 250:	90 e0       	ldi	r25, 0x00	; 0
		res = 1;
        break;
 252:	08 95       	ret

		// activate RFID, password changer
        case 0b11101100:
        key = 11;
 254:	8b e0       	ldi	r24, 0x0B	; 11
 256:	90 e0       	ldi	r25, 0x00	; 0
        break;
 258:	08 95       	ret
//figure out witch key is pressed
int FindKey (){
	//if nothing is pressed
    if (KeypadValue==0b11110000 || KeypadValue==0b00001111)
    {
        return -1;
 25a:	8f ef       	ldi	r24, 0xFF	; 255
 25c:	9f ef       	ldi	r25, 0xFF	; 255
 25e:	08 95       	ret
 260:	8f ef       	ldi	r24, 0xFF	; 255
 262:	9f ef       	ldi	r25, 0xFF	; 255
 264:	08 95       	ret
        key = 11;
        break;

        default:
		// no key is pressed
        return -1;
 266:	8f ef       	ldi	r24, 0xFF	; 255
 268:	9f ef       	ldi	r25, 0xFF	; 255
    }
	return key;
}      
 26a:	08 95       	ret

0000026c <checkPasscode>:

// check weather the password is correct or not (output 0 or 1)
int checkPasscode(int a[], int b[]){
	for(int i = 0; i < 4; i++){
		if(a[i] != b[i]){
 26c:	fc 01       	movw	r30, r24
 26e:	40 81       	ld	r20, Z
 270:	51 81       	ldd	r21, Z+1	; 0x01
 272:	fb 01       	movw	r30, r22
 274:	20 81       	ld	r18, Z
 276:	31 81       	ldd	r19, Z+1	; 0x01
 278:	42 17       	cp	r20, r18
 27a:	53 07       	cpc	r21, r19
 27c:	89 f4       	brne	.+34     	; 0x2a0 <checkPasscode+0x34>
 27e:	dc 01       	movw	r26, r24
 280:	12 96       	adiw	r26, 0x02	; 2
 282:	32 96       	adiw	r30, 0x02	; 2
 284:	08 96       	adiw	r24, 0x08	; 8
 286:	4d 91       	ld	r20, X+
 288:	5d 91       	ld	r21, X+
 28a:	21 91       	ld	r18, Z+
 28c:	31 91       	ld	r19, Z+
 28e:	42 17       	cp	r20, r18
 290:	53 07       	cpc	r21, r19
 292:	49 f4       	brne	.+18     	; 0x2a6 <checkPasscode+0x3a>
	return key;
}      

// check weather the password is correct or not (output 0 or 1)
int checkPasscode(int a[], int b[]){
	for(int i = 0; i < 4; i++){
 294:	a8 17       	cp	r26, r24
 296:	b9 07       	cpc	r27, r25
 298:	b1 f7       	brne	.-20     	; 0x286 <checkPasscode+0x1a>
		if(a[i] != b[i]){
			return 0;
		}	
	}
	return 1;
 29a:	81 e0       	ldi	r24, 0x01	; 1
 29c:	90 e0       	ldi	r25, 0x00	; 0
 29e:	08 95       	ret

// check weather the password is correct or not (output 0 or 1)
int checkPasscode(int a[], int b[]){
	for(int i = 0; i < 4; i++){
		if(a[i] != b[i]){
			return 0;
 2a0:	80 e0       	ldi	r24, 0x00	; 0
 2a2:	90 e0       	ldi	r25, 0x00	; 0
 2a4:	08 95       	ret
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	90 e0       	ldi	r25, 0x00	; 0
		}	
	}
	return 1;
}
 2aa:	08 95       	ret

000002ac <secDelay>:
	while(1){
		if (!(TIFR0 & 0x01)==0){

			TCNT0 = 0x00; //let the clock count from 0

			TIFR0=0x01; //clear timer1 overflow flag
 2ac:	91 e0       	ldi	r25, 0x01	; 1
}

// 10 seconds timer (made on simulation, we have no access to the Atmega1284p)
void secDelay(){
	while(1){
		if (!(TIFR0 & 0x01)==0){
 2ae:	a8 9b       	sbis	0x15, 0	; 21
 2b0:	fe cf       	rjmp	.-4      	; 0x2ae <secDelay+0x2>

			TCNT0 = 0x00; //let the clock count from 0
 2b2:	16 bc       	out	0x26, r1	; 38

			TIFR0=0x01; //clear timer1 overflow flag
 2b4:	95 bb       	out	0x15, r25	; 21

			timer++;
 2b6:	80 91 1a 01 	lds	r24, 0x011A	; 0x80011a <timer>
 2ba:	8f 5f       	subi	r24, 0xFF	; 255
 2bc:	80 93 1a 01 	sts	0x011A, r24	; 0x80011a <timer>
			if (timer == 10)// reset and start over when we have 10 sec
 2c0:	8a 30       	cpi	r24, 0x0A	; 10
 2c2:	a9 f7       	brne	.-22     	; 0x2ae <secDelay+0x2>
			{
				timer = 0;
 2c4:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <timer>
 2c8:	08 95       	ret

000002ca <uart_init>:
	}
}

void uart_init(void){
	// FIX THE BAUD
	UBRR0H = 0;
 2ca:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = 77;
 2ce:	8d e4       	ldi	r24, 0x4D	; 77
 2d0:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	// ACTIVATE RECIVER FOR ATMEGAN so it gets data from RFID, (TX isnt used)
	UCSR0B|=(1<<RXEN0);
 2d4:	e1 ec       	ldi	r30, 0xC1	; 193
 2d6:	f0 e0       	ldi	r31, 0x00	; 0
 2d8:	80 81       	ld	r24, Z
 2da:	80 61       	ori	r24, 0x10	; 16
 2dc:	80 83       	st	Z, r24
	//SET 8 BIT DATA FRAME
	UCSR0C = (1<<UCSZ00)|(1<<UCSZ01);
 2de:	86 e0       	ldi	r24, 0x06	; 6
 2e0:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 2e4:	08 95       	ret

000002e6 <changeKod>:
			}
		}
	}
}

void changeKod(){
 2e6:	0f 93       	push	r16
 2e8:	1f 93       	push	r17
 2ea:	cf 93       	push	r28
 2ec:	df 93       	push	r29
 2ee:	cd b7       	in	r28, 0x3d	; 61
 2f0:	de b7       	in	r29, 0x3e	; 62
 2f2:	28 97       	sbiw	r28, 0x08	; 8
 2f4:	0f b6       	in	r0, 0x3f	; 63
 2f6:	f8 94       	cli
 2f8:	de bf       	out	0x3e, r29	; 62
 2fa:	0f be       	out	0x3f, r0	; 63
 2fc:	cd bf       	out	0x3d, r28	; 61
	// new temp code array
	int newKod[4];
	int i = 0;
 2fe:	00 e0       	ldi	r16, 0x00	; 0
 300:	10 e0       	ldi	r17, 0x00	; 0
	// untill the temp array is filled
	while(newKod[4] != NULL)
 302:	1a c0       	rjmp	.+52     	; 0x338 <changeKod+0x52>
	{
		// chech the pressed button
		tempKeyValue = FindKey();
 304:	58 df       	rcall	.-336    	; 0x1b6 <FindKey>
 306:	90 93 1e 01 	sts	0x011E, r25	; 0x80011e <tempKeyValue+0x1>
 30a:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <tempKeyValue>
		// the key cannot be -1 or reset key or RFID key
		if (tempKeyValue >= 0 && tempKeyValue != 10 && tempKeyValue != 11)
 30e:	99 23       	and	r25, r25
 310:	9c f0       	brlt	.+38     	; 0x338 <changeKod+0x52>
 312:	9c 01       	movw	r18, r24
 314:	2a 50       	subi	r18, 0x0A	; 10
 316:	31 09       	sbc	r19, r1
 318:	22 30       	cpi	r18, 0x02	; 2
 31a:	31 05       	cpc	r19, r1
 31c:	68 f0       	brcs	.+26     	; 0x338 <changeKod+0x52>
		{
			// fill the temp array
			newKod[i] = tempKeyValue;
 31e:	f8 01       	movw	r30, r16
 320:	ee 0f       	add	r30, r30
 322:	ff 1f       	adc	r31, r31
 324:	21 e0       	ldi	r18, 0x01	; 1
 326:	30 e0       	ldi	r19, 0x00	; 0
 328:	2c 0f       	add	r18, r28
 32a:	3d 1f       	adc	r19, r29
 32c:	e2 0f       	add	r30, r18
 32e:	f3 1f       	adc	r31, r19
 330:	91 83       	std	Z+1, r25	; 0x01
 332:	80 83       	st	Z, r24
			i++;
 334:	0f 5f       	subi	r16, 0xFF	; 255
 336:	1f 4f       	sbci	r17, 0xFF	; 255
void changeKod(){
	// new temp code array
	int newKod[4];
	int i = 0;
	// untill the temp array is filled
	while(newKod[4] != NULL)
 338:	89 85       	ldd	r24, Y+9	; 0x09
 33a:	9a 85       	ldd	r25, Y+10	; 0x0a
 33c:	89 2b       	or	r24, r25
 33e:	11 f7       	brne	.-60     	; 0x304 <changeKod+0x1e>
		
	}
	// change mother array
	for (int i = 0; i < 4; i++)
	{
		kod[i] = newKod[i];
 340:	ed e0       	ldi	r30, 0x0D	; 13
 342:	f1 e0       	ldi	r31, 0x01	; 1
 344:	89 81       	ldd	r24, Y+1	; 0x01
 346:	9a 81       	ldd	r25, Y+2	; 0x02
 348:	91 83       	std	Z+1, r25	; 0x01
 34a:	80 83       	st	Z, r24
 34c:	8b 81       	ldd	r24, Y+3	; 0x03
 34e:	9c 81       	ldd	r25, Y+4	; 0x04
 350:	93 83       	std	Z+3, r25	; 0x03
 352:	82 83       	std	Z+2, r24	; 0x02
 354:	8d 81       	ldd	r24, Y+5	; 0x05
 356:	9e 81       	ldd	r25, Y+6	; 0x06
 358:	95 83       	std	Z+5, r25	; 0x05
 35a:	84 83       	std	Z+4, r24	; 0x04
 35c:	8f 81       	ldd	r24, Y+7	; 0x07
 35e:	98 85       	ldd	r25, Y+8	; 0x08
 360:	97 83       	std	Z+7, r25	; 0x07
 362:	86 83       	std	Z+6, r24	; 0x06
	}
}
 364:	28 96       	adiw	r28, 0x08	; 8
 366:	0f b6       	in	r0, 0x3f	; 63
 368:	f8 94       	cli
 36a:	de bf       	out	0x3e, r29	; 62
 36c:	0f be       	out	0x3f, r0	; 63
 36e:	cd bf       	out	0x3d, r28	; 61
 370:	df 91       	pop	r29
 372:	cf 91       	pop	r28
 374:	1f 91       	pop	r17
 376:	0f 91       	pop	r16
 378:	08 95       	ret

0000037a <rfidCheck>:
	// ACTIVATE RECIVER FOR ATMEGAN so it gets data from RFID, (TX isnt used)
	UCSR0B|=(1<<RXEN0);
	//SET 8 BIT DATA FRAME
	UCSR0C = (1<<UCSZ00)|(1<<UCSZ01);
}
void rfidCheck(){
 37a:	ef 92       	push	r14
 37c:	ff 92       	push	r15
 37e:	0f 93       	push	r16
 380:	1f 93       	push	r17
 382:	cf 93       	push	r28
 384:	df 93       	push	r29
	uart_init();
 386:	a1 df       	rcall	.-190    	; 0x2ca <uart_init>
	int numOfMatches = 0;
	// See if atmega is receiving info
	while((UCSR0A)&(1<<RXC0))
 388:	c0 ec       	ldi	r28, 0xC0	; 192
 38a:	d0 e0       	ldi	r29, 0x00	; 0
	{
		//REVICE DATA
		value[rfidCharPos]=UDR0;
 38c:	06 ec       	ldi	r16, 0xC6	; 198
 38e:	10 e0       	ldi	r17, 0x00	; 0
 390:	0f 2e       	mov	r0, r31
 392:	f3 e3       	ldi	r31, 0x33	; 51
 394:	ef 2e       	mov	r14, r31
 396:	f1 e0       	ldi	r31, 0x01	; 1
 398:	ff 2e       	mov	r15, r31
 39a:	f0 2d       	mov	r31, r0
}
void rfidCheck(){
	uart_init();
	int numOfMatches = 0;
	// See if atmega is receiving info
	while((UCSR0A)&(1<<RXC0))
 39c:	36 c0       	rjmp	.+108    	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
	{
		//REVICE DATA
		value[rfidCharPos]=UDR0;
 39e:	f8 01       	movw	r30, r16
 3a0:	80 81       	ld	r24, Z
 3a2:	e0 91 16 01 	lds	r30, 0x0116	; 0x800116 <__data_end>
 3a6:	f0 91 17 01 	lds	r31, 0x0117	; 0x800117 <__data_end+0x1>
 3aa:	e9 5d       	subi	r30, 0xD9	; 217
 3ac:	fe 4f       	sbci	r31, 0xFE	; 254
 3ae:	80 83       	st	Z, r24
 3b0:	89 ef       	ldi	r24, 0xF9	; 249
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	01 97       	sbiw	r24, 0x01	; 1
 3b6:	f1 f7       	brne	.-4      	; 0x3b4 <rfidCheck+0x3a>
 3b8:	00 c0       	rjmp	.+0      	; 0x3ba <rfidCheck+0x40>
 3ba:	00 00       	nop
		_delay_ms(1);
		rfidCharPos++;
 3bc:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <__data_end>
 3c0:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <__data_end+0x1>
 3c4:	01 96       	adiw	r24, 0x01	; 1
 3c6:	90 93 17 01 	sts	0x0117, r25	; 0x800117 <__data_end+0x1>
 3ca:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
		//PAUS WHEN ATMEGA HAVE 12 NUMBERS
		if (rfidCharPos==12){
 3ce:	0c 97       	sbiw	r24, 0x0c	; 12
 3d0:	e1 f4       	brne	.+56     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
 3d2:	e7 e2       	ldi	r30, 0x27	; 39
 3d4:	f1 e0       	ldi	r31, 0x01	; 1
 3d6:	a0 e0       	ldi	r26, 0x00	; 0
 3d8:	b1 e0       	ldi	r27, 0x01	; 1
 3da:	20 e0       	ldi	r18, 0x00	; 0
 3dc:	30 e0       	ldi	r19, 0x00	; 0
			for(int j=0;j < 12;j++)
			{
				// check if both arrays (Card, data) are the same and increase numOfMatches by 1 up to 12
				if(value[j]==value1[j]) numOfMatches++;
 3de:	91 91       	ld	r25, Z+
 3e0:	8d 91       	ld	r24, X+
 3e2:	98 13       	cpse	r25, r24
 3e4:	02 c0       	rjmp	.+4      	; 0x3ea <rfidCheck+0x70>
 3e6:	2f 5f       	subi	r18, 0xFF	; 255
 3e8:	3f 4f       	sbci	r19, 0xFF	; 255
		value[rfidCharPos]=UDR0;
		_delay_ms(1);
		rfidCharPos++;
		//PAUS WHEN ATMEGA HAVE 12 NUMBERS
		if (rfidCharPos==12){
			for(int j=0;j < 12;j++)
 3ea:	ee 15       	cp	r30, r14
 3ec:	ff 05       	cpc	r31, r15
 3ee:	b9 f7       	brne	.-18     	; 0x3de <rfidCheck+0x64>
			{
				// check if both arrays (Card, data) are the same and increase numOfMatches by 1 up to 12
				if(value[j]==value1[j]) numOfMatches++;
			}
			// CHANGE PASSWORD and interrupt if they are the same
			if(numOfMatches==12) {
 3f0:	2c 30       	cpi	r18, 0x0C	; 12
 3f2:	31 05       	cpc	r19, r1
 3f4:	31 f4       	brne	.+12     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
				rfidCharPos=0;
 3f6:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <__data_end+0x1>
 3fa:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <__data_end>
				numOfMatches=0;
				changeKod();
 3fe:	73 df       	rcall	.-282    	; 0x2e6 <changeKod>
 400:	04 c0       	rjmp	.+8      	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
			}
			//no matach == redo 
			else{
				rfidCharPos=0;
 402:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <__data_end+0x1>
 406:	10 92 16 01 	sts	0x0116, r1	; 0x800116 <__data_end>
}
void rfidCheck(){
	uart_init();
	int numOfMatches = 0;
	// See if atmega is receiving info
	while((UCSR0A)&(1<<RXC0))
 40a:	88 81       	ld	r24, Y
 40c:	88 23       	and	r24, r24
 40e:	3c f2       	brlt	.-114    	; 0x39e <rfidCheck+0x24>
				rfidCharPos=0;
				numOfMatches=0;
			}
		}
	}
}
 410:	df 91       	pop	r29
 412:	cf 91       	pop	r28
 414:	1f 91       	pop	r17
 416:	0f 91       	pop	r16
 418:	ff 90       	pop	r15
 41a:	ef 90       	pop	r14
 41c:	08 95       	ret

0000041e <main>:
}


int main(void)
{
	servoLedCompo = 0b00001011;// led and servo are outputs
 41e:	8b e0       	ldi	r24, 0x0B	; 11
 420:	84 b9       	out	0x04, r24	; 4
	ledCompoControll |= 0b00000001; //red is always on
 422:	28 9a       	sbi	0x05, 0	; 5
	
	//making first 4 of the keypad input, and the rest are outputs
    KeypadDir = 0b00001111;
 424:	8f e0       	ldi	r24, 0x0F	; 15
 426:	87 b9       	out	0x07, r24	; 7
	//assign high as a value
    KeypadCon = 0b11110000;
 428:	80 ef       	ldi	r24, 0xF0	; 240
 42a:	88 b9       	out	0x08, r24	; 8

//Timer
	TCNT0 = 0x00; //let a clock count from 0 
 42c:	16 bc       	out	0x26, r1	; 38
	TCCR0B |= 0b00000101; //prescaling 1024
 42e:	85 b5       	in	r24, 0x25	; 37
 430:	85 60       	ori	r24, 0x05	; 5
 432:	85 bd       	out	0x25, r24	; 37
	
	//constant check if we have the right passcode 
	int i = 0;
 434:	c0 e0       	ldi	r28, 0x00	; 0
 436:	d0 e0       	ldi	r29, 0x00	; 0
    while (1) 
    {
		if (res == 1)
		{
			memset(inputKod, 0, sizeof(inputKod));
 438:	0f e1       	ldi	r16, 0x1F	; 31
 43a:	11 e0       	ldi	r17, 0x01	; 1
			//compare the arrays to check if the passcode is correct (open lock if it is)
			if (checkPasscode(inputKod, kod) == 1)
			{
				dddd = 1; // for testing
				
				ICR1= 4999;  // for servo
 43c:	0f 2e       	mov	r0, r31
 43e:	f6 e8       	ldi	r31, 0x86	; 134
 440:	af 2e       	mov	r10, r31
 442:	b1 2c       	mov	r11, r1
 444:	f0 2d       	mov	r31, r0
 446:	0f 2e       	mov	r0, r31
 448:	f7 e8       	ldi	r31, 0x87	; 135
 44a:	cf 2e       	mov	r12, r31
 44c:	f3 e1       	ldi	r31, 0x13	; 19
 44e:	df 2e       	mov	r13, r31
 450:	f0 2d       	mov	r31, r0
				//guarantee to the positive +
				servoLedCompo &= 0b11110111;
				//turn 90 deg(opened)
				OCR1A=-97; // + (to left)
 452:	0f 2e       	mov	r0, r31
 454:	f8 e8       	ldi	r31, 0x88	; 136
 456:	ef 2e       	mov	r14, r31
 458:	f1 2c       	mov	r15, r1
 45a:	f0 2d       	mov	r31, r0
 45c:	0f 2e       	mov	r0, r31
 45e:	ff e9       	ldi	r31, 0x9F	; 159
 460:	8f 2e       	mov	r8, r31
 462:	99 24       	eor	r9, r9
 464:	9a 94       	dec	r9
 466:	f0 2d       	mov	r31, r0
			
				ledCompoControll &= 0b11111100; // turn off green (servo remains)
				ledCompoControll |= 0b00000001; // turn on red
			
				//back to 0 deg (locked)
				OCR1A=97; // - (to right)
 468:	0f 2e       	mov	r0, r31
 46a:	f1 e6       	ldi	r31, 0x61	; 97
 46c:	6f 2e       	mov	r6, r31
 46e:	71 2c       	mov	r7, r1
 470:	f0 2d       	mov	r31, r0
			}
		
			//compare the arrays to check if the passcode is correct (open lock if it is)
			if (checkPasscode(inputKod, kod) == 1)
			{
				dddd = 1; // for testing
 472:	44 24       	eor	r4, r4
 474:	43 94       	inc	r4
 476:	51 2c       	mov	r5, r1
	
	//constant check if we have the right passcode 
	int i = 0;
    while (1) 
    {
		if (res == 1)
 478:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <res>
 47c:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <res+0x1>
 480:	01 97       	sbiw	r24, 0x01	; 1
 482:	09 f0       	breq	.+2      	; 0x486 <main+0x68>
 484:	50 c0       	rjmp	.+160    	; 0x526 <main+0x108>
		{
			memset(inputKod, 0, sizeof(inputKod));
 486:	88 e0       	ldi	r24, 0x08	; 8
 488:	f8 01       	movw	r30, r16
 48a:	11 92       	st	Z+, r1
 48c:	8a 95       	dec	r24
 48e:	e9 f7       	brne	.-6      	; 0x48a <main+0x6c>
 490:	ff e3       	ldi	r31, 0x3F	; 63
 492:	2d e0       	ldi	r18, 0x0D	; 13
 494:	83 e0       	ldi	r24, 0x03	; 3
 496:	f1 50       	subi	r31, 0x01	; 1
 498:	20 40       	sbci	r18, 0x00	; 0
 49a:	80 40       	sbci	r24, 0x00	; 0
 49c:	e1 f7       	brne	.-8      	; 0x496 <main+0x78>
 49e:	00 c0       	rjmp	.+0      	; 0x4a0 <main+0x82>
 4a0:	00 00       	nop
			i = 0;
			_delay_ms(1000);
			res = 0;
 4a2:	10 92 19 01 	sts	0x0119, r1	; 0x800119 <res+0x1>
 4a6:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <res>
    while (1) 
    {
		if (res == 1)
		{
			memset(inputKod, 0, sizeof(inputKod));
			i = 0;
 4aa:	c0 e0       	ldi	r28, 0x00	; 0
 4ac:	d0 e0       	ldi	r29, 0x00	; 0
 4ae:	3b c0       	rjmp	.+118    	; 0x526 <main+0x108>
			res = 0;
		}
		while (res == 0)
		{
			//get the pressed key value temporarly and check weather it is in the range or not
			tempKeyValue = FindKey();
 4b0:	82 de       	rcall	.-764    	; 0x1b6 <FindKey>
 4b2:	90 93 1e 01 	sts	0x011E, r25	; 0x80011e <tempKeyValue+0x1>
 4b6:	80 93 1d 01 	sts	0x011D, r24	; 0x80011d <tempKeyValue>
			if (tempKeyValue == 11)
 4ba:	0b 97       	sbiw	r24, 0x0b	; 11
			{
				rfidCheck();
 4bc:	09 f4       	brne	.+2      	; 0x4c0 <main+0xa2>
 4be:	5d df       	rcall	.-326    	; 0x37a <rfidCheck>
			}
			if (tempKeyValue >= 0)
 4c0:	80 91 1d 01 	lds	r24, 0x011D	; 0x80011d <tempKeyValue>
 4c4:	90 91 1e 01 	lds	r25, 0x011E	; 0x80011e <tempKeyValue+0x1>
 4c8:	99 23       	and	r25, r25
 4ca:	6c f0       	brlt	.+26     	; 0x4e6 <main+0xc8>
			{
				//insert the tempKeyValue in the array 
				inputKod[i] = tempKeyValue;
 4cc:	fe 01       	movw	r30, r28
 4ce:	ee 0f       	add	r30, r30
 4d0:	ff 1f       	adc	r31, r31
 4d2:	e1 5e       	subi	r30, 0xE1	; 225
 4d4:	fe 4f       	sbci	r31, 0xFE	; 254
 4d6:	91 83       	std	Z+1, r25	; 0x01
 4d8:	80 83       	st	Z, r24
				i++;
 4da:	21 96       	adiw	r28, 0x01	; 1
				if(i == 4){i = 0;}
 4dc:	c4 30       	cpi	r28, 0x04	; 4
 4de:	d1 05       	cpc	r29, r1
 4e0:	11 f4       	brne	.+4      	; 0x4e6 <main+0xc8>
 4e2:	c0 e0       	ldi	r28, 0x00	; 0
 4e4:	d0 e0       	ldi	r29, 0x00	; 0
			}
		
			//compare the arrays to check if the passcode is correct (open lock if it is)
			if (checkPasscode(inputKod, kod) == 1)
 4e6:	6d e0       	ldi	r22, 0x0D	; 13
 4e8:	71 e0       	ldi	r23, 0x01	; 1
 4ea:	c8 01       	movw	r24, r16
 4ec:	bf de       	rcall	.-642    	; 0x26c <checkPasscode>
 4ee:	01 97       	sbiw	r24, 0x01	; 1
 4f0:	d1 f4       	brne	.+52     	; 0x526 <main+0x108>
			{
				dddd = 1; // for testing
 4f2:	50 92 1c 01 	sts	0x011C, r5	; 0x80011c <dddd+0x1>
 4f6:	40 92 1b 01 	sts	0x011B, r4	; 0x80011b <dddd>
				
				ICR1= 4999;  // for servo
 4fa:	f5 01       	movw	r30, r10
 4fc:	d1 82       	std	Z+1, r13	; 0x01
 4fe:	c0 82       	st	Z, r12
				//guarantee to the positive +
				servoLedCompo &= 0b11110111;
 500:	23 98       	cbi	0x04, 3	; 4
				//turn 90 deg(opened)
				OCR1A=-97; // + (to left)
 502:	f7 01       	movw	r30, r14
 504:	91 82       	std	Z+1, r9	; 0x01
 506:	80 82       	st	Z, r8
				//reset DDRB so servo can turn the other way
				servoLedCompo &= 0b11110111;
 508:	23 98       	cbi	0x04, 3	; 4
			
				ledCompoControll &= 0b11111100; // turn off red (servo remains)
 50a:	85 b1       	in	r24, 0x05	; 5
 50c:	8c 7f       	andi	r24, 0xFC	; 252
				ledCompoControll |= 0b00000010; // turn on green
 50e:	85 b9       	out	0x05, r24	; 5
			
				//wait 10 sec
				secDelay();
 510:	29 9a       	sbi	0x05, 1	; 5
 512:	cc de       	rcall	.-616    	; 0x2ac <secDelay>
				//guarantee to the negative 
				servoLedCompo &= 0b11110111;
 514:	23 98       	cbi	0x04, 3	; 4
			
				ledCompoControll &= 0b11111100; // turn off green (servo remains)
 516:	85 b1       	in	r24, 0x05	; 5
 518:	8c 7f       	andi	r24, 0xFC	; 252
 51a:	85 b9       	out	0x05, r24	; 5
				ledCompoControll |= 0b00000001; // turn on red
 51c:	28 9a       	sbi	0x05, 0	; 5
			
				//back to 0 deg (locked)
				OCR1A=97; // - (to right)
 51e:	f7 01       	movw	r30, r14
 520:	71 82       	std	Z+1, r7	; 0x01
 522:	60 82       	st	Z, r6
				//reset DDRB so servo can turn the other way
				servoLedCompo &= 0b11110111;
 524:	23 98       	cbi	0x04, 3	; 4
			memset(inputKod, 0, sizeof(inputKod));
			i = 0;
			_delay_ms(1000);
			res = 0;
		}
		while (res == 0)
 526:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <res>
 52a:	90 91 19 01 	lds	r25, 0x0119	; 0x800119 <res+0x1>
 52e:	89 2b       	or	r24, r25
 530:	09 f4       	brne	.+2      	; 0x534 <main+0x116>
 532:	be cf       	rjmp	.-132    	; 0x4b0 <main+0x92>
 534:	a1 cf       	rjmp	.-190    	; 0x478 <main+0x5a>

00000536 <__tablejump2__>:
 536:	ee 0f       	add	r30, r30
 538:	ff 1f       	adc	r31, r31
 53a:	00 24       	eor	r0, r0
 53c:	00 1c       	adc	r0, r0
 53e:	0b be       	out	0x3b, r0	; 59
 540:	07 90       	elpm	r0, Z+
 542:	f6 91       	elpm	r31, Z
 544:	e0 2d       	mov	r30, r0
 546:	09 94       	ijmp

00000548 <_exit>:
 548:	f8 94       	cli

0000054a <__stop_program>:
 54a:	ff cf       	rjmp	.-2      	; 0x54a <__stop_program>
